- **第一章 欢迎使用Node.js**

  ​        一些原则和设计模式从字面上定义了开发人员对Node.js 平台及其生态系统的体验。最奇特的可能是它的异步特性和编程风格，最简单的形式就是大量使用回调。这是非常重要的，我们首先要深入了解这些基本原则和模式，而不仅仅是为了编写正确的代码，并且要能够在解决更大、更复杂的问题时做出有效的设计决策。

  ​        Node.js的另一个特点是它的哲学。实际上，学习Node.js不仅是简单地学习新技术，它还具有更多优势。并且它也在拥抱一种文化和一种社区。我们将看到它如何极大地影响我们设计应用程序和组件的方式，以及它们与社区创建的应用程序和组件进行交互的方式。除了这些方面，值得一提的是，最新版本的Node.js 引入了对ES2015（前身称为ES6）描述的许多功能的支持，这使该语言更有表现力，使用起来更愉快。为了能够生成更简洁和可读的代码，并提出实现我们将在本书中看到的设计模式的替代方法，接受这些语言中新的语法和功能的补充是很重要的。

  ​        在本章中，我们将学习以下主题：

  ​              - Node.js理念， “Node的方式”

  ​              - Node.js版本6和ES2015

  ​              - 反应器模式-Node.js 异步体系结构的核心机制

  

  - **1.1 Node.js哲学**

    ​        每个平台都有其自己的哲学——一组被社区普遍接受的原则和准则，一种影响平台发展的思想，以及如何开发和设计应用程序。这些原则中的一些源于技术本身，其中一些由其生态系统支持，一些只是社区中的趋势，而其他则是不同意识形态的演变。在Node.js中，其中一些原理直接来自其创建者Ryan Dahl。所有为核心做出贡献的人；来自社区中有魅力的人物；还有一些其中的一些原理是从JavaScript文化中继承的，或者受Unix 哲学的影响。这些规则都不是强加的，它们总是以常识来应用；但是，当我们在设计程序时寻找灵感的来源时，它们被证明是非常有用的。

    注：您可以在Wikipedia上找到大量的软件开发理念。维基百科: [h t t p : / / e n . w i k i p e d i a . o r g / w i k i / L i s t _ o f _ s o f t w a r e _ d e v e l o p m e n t _ p h i l o s o p h i e]()  

    - **1.1.1 小型内核**

      ​        Node.js内核本身有一些原则为基础。其中之一是最小的功能集，其余部分留给所谓的userland （或userspace ），即位于核心外部的模块生态系统。该原则对Node.js文化产生了巨大影响，因为它为社区提供了自由，使其可以在用户域模块范围内进行实验和快速迭代，以使用更广泛的解决方案，而不是使用一个缓慢发展的解决方案，即内置在更加严格控制和稳定的核心中。这样，将核心功能集保持在最低限度，不仅在可维护性方面变得很方便，而且在其对整个生态系统的发展带来的积极文化影响方面也变得很方便。

    - **1.1.2小模块**

      ​        Node.js使用模块的概念作为构建程序代码的基本方法。它是用于创建应用程序和可重用库（称为包）的构建块（包通常也称为模块，因为通常它只有一个模块作为入口点）。在Node.js中，最广为传播的原则之一是设计小型模块，不仅是在代码大小方面，而且最重要的是在范围方面。

      ​        该原则起源于Unix哲学，特别是它的两个原则如下：

      ​              -  “Small is beautiful.” （ “小巧是美丽的）。

      ​              -  “Make each program do one thing well.” （“让每个程序都做好一件事情。”）

      ​        Node.js将这些概念带入了一个全新的高度。在官方包管理器npm的帮助下，Node.js帮助解决了依赖地狱问题，它确保每个安装的包都有自己独立的依赖集，从而使一个程序可以依赖很多包而不会引起冲突。实际上，Node方式涉及极高的可重用性，因此应用程序由大量小的，集中的依赖项组成。尽管这在其他平台上被认为是不切实际的，甚至是完全不可行的，但在Node.js中，鼓励这种做法。因此，发现包含少于100行代码或仅公开一个功能的npm软件包并不罕见。

      ​         除了在可重用性方面的明显优势外，还考虑了以下一个小模块

      ​                 - Easier to understand and use （ 更易于理解和使用）

      ​                 -  Simpler to test and maintain （易于测试和维护）

      ​                 -  Perfect to share with the browser （完美与浏览器共享）

      ​        具有更小，更集中的模块使每个人甚至都可以共享或重用最小的一段代码；这是“  Don't Repeat Yourself (DRY) （不要再重复自己）”原则应用于全新的水平。

    - **1.1.3 小面积**

      ​        除了体积和范围较小之外，Node.js模块通常还具有暴露最少功能集的特性。这里的主要优势是增加了API的可用性，这意味着该API变得更易于使用，并且较少被错误使用。实际上，大多数时候，组件的用户只对一组功能非常有限且集中的特性感兴趣，而无需扩展其功能或使用更高级的方面。

      ​        在Node.js中，定义模块的一种非常常见的模式是仅公开一项功能，例如函数或构造函数，同时让更高级的方面或次要特性成为导出的函数或构造函数的属性。这有助于用户什么是识别重要的，什么是次要的。找到仅暴露一个函数而没有暴露其他功能的模块并不罕见，因为它提供了一个单一的，明确无误的入口点。

      ​        许多Node.js模块的另一个特点是创建它们是为了使用而不是扩展。通过禁止任何扩展的可能性来锁定模块的内部可能听起来不灵活，但它实际上具有减少用例、简化其实现、促进其维护和增加其可用性的优点。

    - **1.1.4 简单和实用主义**

      ​        您是否曾听说过”  Keep It Simple, Stupid （KISS ）（保持简单、愚蠢）原则“或著名的名言：

      ​              “简单是最终的复杂性。” ——莱昂纳多·达·芬奇

      ​        著名的计算机科学家理查德  P·加布里尔(Richard P. Gabriel)创造了“越差越好”这个术语来描述这个模型，因此少而简单的功能是软件的理想设计选择。在他的论文《更糟的崛起》中，他说：“设计必须在实现和接口上都简单。简单的实现比接口更重要。简洁是设计中最重要的考虑因素。”与简单，相对于完善的，功能齐全的软件相比，设计好的做法是出于以下几个原因：花费更少的精力实施，使用更少的资源实现更快的运输，更容易适应，更易于维护和理解。这些因素促进了社区的贡献，并使软件本身得以发展和改进。

      ​        在Node.js中，JavaScript也支持这个原则，它是一种非常实用的语言。实际上，看到简单的函数，闭包和对象文字替换复杂的类层次结构并不罕见。纯粹的面向对象设计经常试图使用计算机系统的数学术语来复制现实世界，而不考虑现实世界本身的不完善性和复杂性。事实是：我们的软件始终是现实的近似，并且我们可能会在尝试更快地工作并具有合理的复杂性方面取得更大的成功，而不是尝试花费大量的精力和大量的代码来创建接近完美的软件。

      ​        在本书中，我们将看到这一原则在许多方面的应用。例如，相当多的传统设计模式，例如单例或装饰器，有时不是很简单的，琐碎的实现，但是在大多数情况下，简单，实用的方法(大多数情况下)比单纯、完美的设计更受欢迎。

  - **1.2 Node.js 6和ES2015简介**

    ​        撰写本文时，Node.js的最新主要版本（版本4、5和6）都带有对ECMAScript 2015规范中引入的新功能的增强语言支持。（简称ES2015，以前也称为ES6），旨在使JavaScript语言更加灵活和有趣。

    ​        在本书中，我们将在代码示例中广泛采用其中的一些新功能。这些概念在Node.js社区中仍然很新鲜，因此值得快速浏览一下Node.js当前支持的最重要的ES2015特定功能。我们的参考版本为Node.js版本6。

    ​        根据您的Node.js版本，其中某些功能仅在启用严格模式后才能正常工作。通过在脚本的开头添加“ use strict” 语句，可以轻松启用严格模式。请注意，“ use strict” 语句是一个纯字符串，您可以使用单引号或双引号对其进行声明。为了简洁起见，我们不会在代码示例中编写此行，但是您应该记住添加它以便能够正确运行它们。

    ​        以下列表并不意味着详尽无遗，而只是对Node.js支持的某些ES2015功能的介绍，因此您可以轻松理解本书其余部分中的所有代码示例。

    - **1.2.1 Let和Const关键字**

      ​       过去，JavaScript只提供函数范围和全局范围来控制变量的生存期和可见性。例如，如果您在if语句的主体中声明了一个变量，那么即使在语句外部也可以访问该变量，不管是否执行了语句的主体。举个例子，让我们看得更清楚些：

      ```
      if (false) {
       var x = "hello";
      }
      console.log(x);
      ```

      ​        这段代码不会像我们预期的结果，即失败，它只会在控制台中打印undefined。这种行为已经导致了许多bug和许多让人感到挫折的结果，这就是为什么ES2015引入let关键字来声明块作用域的原因。让我们在之前的例子中用Let代替evar:

      ```
      if (false) {
       let x = "hello";
      }
      console.log(x);
      ```

      ​        这段代码将引发一个  ReferenceError: x is not defined ，因为我们试图打印一个已经在另一个块中定义的变量。为了给出一个更有意义的例子，我们可以使用let关键字来定义一个临时变量作为循环的索引:

      ```
      for (let i=0; i < 10; i++) {
       // do something here
      }
      console.log(i);
      ```

      ​        与前面的示例一样，这段代码将引发一个 ReferenceError: i is not defined 错误

      ​        let引入的这种保护行为允许我们编写更安全的代码，因为如果我们意外地访问属于另一个范围的变量，我们将得到一个错误，这将允许我们轻松地发现错误并避免潜在的危险副作用。

      ES2015还引入了const关键字。这个关键字允许我们声明常量变量。我们来看一个简单的例子:

      ```
      const x = 'This will never change';
      x = '...';
      ```

      ​        这段代码将引发一个 ReferenceError: i is not defined 错误，因为我们要改变一个常数的值。

      ​        无论如何，重点要强调的是，在许多其他语言中，const的行为与常量值不同，在其他语言中，这个关键字允许我们定义只读变量。事实上，在ES2015中，const并没有表示赋值是常量，而是表示与值的绑定是常量。为了澄清这一概念，我们可以看到，在ES2015的const中，仍然可以做类似的事情:

      ```
      const x = {};
      x.name = 'John';
      ```

      ​        当我们改变对象内部的属性时，我们实际上是在改变值(对象)，但是变量和对象之间的绑定不会改变，所以这段代码不会引起错误。相反，如果我们重新分配完整的变量，这将改变变量和它的值之间的绑定，并产生一个错误:

      ```
      x = null; // This will fail
      ```

      ​        当您希望保护一个标量值不被意外地更改时，或者更一般地说，当您希望保护一个已分配的变量被意外地重新分配到代码中其他地方的另一个值时，常量是非常有用的。

      ​        在脚本中需要模块时使用const是最佳实践，这样就不会意外地重新分配包含模块的变量:

      ```
      const path = require('path');
      // .. do stuff with the path module
      let path = './some/path'; // this will fail
      ```

      注：如果你想创造一个不变的对象，const还不够，那么你应该使用es5的方法 Object.freeze() ( [h t t p s : / / d e v e l o p e r . m o z i l l a . o r g / i t / d o c s / W e b / J a v a S c r i p t / R e f e r e n c e / G l o b a l _ O b j e c t s / O b j e c t / f r e e z]()  )或者deep-freeze模块  ([h t t p s : / / w w w . n p m j s . c o m / p a c k a g e / d e e p - f r e e z e]()). 

    - **1.2.2箭头函数**

      ​        ES2015引入的最受欢迎的特性之一是对箭头函数的支持。对于定义函数，arrow函数是一种更简洁的语法，在定义回调时尤其有用。为了更好地理解这种语法的优点，让我们先来看一个典型的数组过滤的例子:

      ```
      const numbers = [2, 6, 7, 8, 1];
      const even = numbers.filter(function(x) {
       return x%2 === 0;
      });
      ```

      ​        前面的代码可以重写如下使用箭头函数语法:

      ```
      const numbers = [2, 6, 7, 8, 1];
      const even = numbers.filter(x => x%2 === 0);
      ```

      ​        过滤器函数可以内联定义，关键字函数被删除，只留下参数列表，后面跟着=>(箭头)，然后是函数的主体。当参数列表包含多个参数时，必须用括号括起它们，并用逗号分隔参数。另外，当没有参数时，您必须在箭头()=>{…}之前提供一组空括号。当函数体只有一行时，不需要编写return关键字，因为它是隐式应用的。如果我们需要添加更多的代码行到函数体中，我们可以用花括号把它们括起来，但是要注意，在这种情况下，返回不是自动隐含的，所以需要显式地声明，如下面的例子所示:

      ```
      const numbers = [2, 6, 7, 8, 1];
      const even = numbers.filter(x => {
       if (x%2 === 0) {
       console.log(x + ' is even!');
       return true;
       }
      });
      ```

      ​        但是，关于arrow函数还有一个重要的特性需要了解:arrow函数被绑定到它们的词法范围。这意味着在一个箭头函数中，它的值与父块中的值相同。让我们用一个例子来阐明这个概念:

      ```
      function DelayedGreeter(name) {
       this.name = name;
      }
      DelayedGreeter.prototype.greet = function() {
       setTimeout( function cb() {
       console.log('Hello ' + this.name);
       }, 500);
      };
      const greeter = new DelayedGreeter('World');
      greeter.greet(); // will print "Hello undefined"
      ```

      ​        在这段代码中，我们定义了一个简单的接收name作为参数的greeter原型。然后我们将greet方法添加到原型中。这个函数应该打印Hello和当前实例中在调用后500毫秒定义的name。但是这个函数被破坏了，因为在timeout回调函数(cb)中，函数的作用域与greet方法的作用域不同，而且this的值是undefined。

      ​       在Node.js引入对arrow函数的支持之前，为了解决这个问题，我们需要使用bind修改greet函数，如下所示:

      ```
      DelayedGreeter.prototype.greet = function() {
       setTimeout( () => console.log('Hello' + this.name), 500);
      };
      ```

      ​        这是一个非常方便的特性;大多数情况下，它使我们的代码更加简洁和直观。

    - **1.2.3 Class语法**

      ​       ES2015引入了一种新的语法，以一种所有来自经典面向对象语言(如Java或c#)的开发人员应该更熟悉的方式利用原型继承。需要强调的是，这种新语法不会改变JavaScript运行时内部管理对象的方式;它们仍然通过原型而不是类继承属性和函数。虽然这种新的替代语法非常方便和可读，但是作为开发人员，理解它只是语法糖是很重要的。

      ​        我们来看一个简单的例子。首先，让我们用经典的基于原型的方法来描述一个Person函数:

      ```
      function Person(name, surname, age) {
       this.name = name;
       this.surname = surname;
       this.age = age;
      }
      Person.prototype.getFullName = function() {
       return this.name + '' + this.surname;
      };
      Person.older = function(person1, person2) {
       return (person1.age >= person2.age) ? person1 : person2;
      };
      ```

      ​        正如你看到的，一个人有名字、姓氏和年龄。我们为原型提供了一个帮助函数，该帮助函数允许我们轻松地获取person对象的全名，而一个通用的帮助函数则可以直接从person原型访问，该原型在两个person实例之间返回年龄更大的person实例作为输入。

      现在让我们看看如何使用新的ES2015 class语法实现相同的例子:

      ```
      class Person {
       constructor (name, surname, age) {
       this.name = name;
       this.surname = surname;
       this.age = age;
       }
       getFullName () {
       return this.name + ' ' + this.surname;
       }
       static older (person1, person2) {
       return (person1.age >= person2.age) ? person1 : person2;
       }
      }
      ```

      ​        这种语法更易于阅读和理解。我们显式地声明类的constructor是什么，并将older的函数声明为静态方法。

      ​        这两种实现是完全可互换的，但是新语法的真正关键功能是可以使用扩展和super关键字扩展Person原型。假设我们想创建一个PersonWithMiddlename类:

      ```
      class PersonWithMiddlename extends Person {
       constructor (name, middlename, surname, age) {
       super(name, surname, age);
       this.middlename = middlename;
       }
       getFullName () {
       return this.name + '' + this.middlename + '' + this.surname;
       }
      }
      ```

      ​        值得注意的是，在第三个示例中，语法与其他面向对象语言中的常见语法非常相似。我们声明了要扩展的类，我们定义了一个新的构造函数，它可以使用关键字super调用父类，我们还覆盖了getFullName方法来添加对中间名的支持。

